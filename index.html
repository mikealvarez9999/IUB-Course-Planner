<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>IUB Course Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- PWA: manifest + theme colors + Apple -->
  <link rel="manifest" href="manifest.webmanifest" crossorigin="use-credentials" />
  <meta name="theme-color" content="#0b0f14" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#f3f4f6" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

  <!-- Favicons -->
  <link rel="icon" href="icons/icon-round.png" type="image/png" />
  <link rel="icon" href="icons/favicon.svg" type="image/svg+xml" />

  <link rel="stylesheet" href="styles.css" />

  <!-- Google Analytics (GA4) - replace with your measurement ID -->
  <script>
    (function(){
      const GA_MEASUREMENT_ID = 'G-DW57CD9V2F'; // TODO: replace with your GA4 measurement ID
      if (!GA_MEASUREMENT_ID || GA_MEASUREMENT_ID === 'G-DW57CD9V2F') return;
      const s = document.createElement('script');
      s.async = true;
      s.src = 'https://www.googletagmanager.com/gtag/js?id=' + GA_MEASUREMENT_ID;
      document.head.appendChild(s);
      window.dataLayer = window.dataLayer || [];
      function gtag(){ dataLayer.push(arguments); }
      window.gtag = gtag;
      gtag('js', new Date());
      gtag('config', GA_MEASUREMENT_ID, { anonymize_ip: true, transport_type: 'beacon' });
    })();
  </script>
</head>
<body>
  <header id="appHeader">
    <div class="brand">
      <h1>IUB Course Planner</h1>
      <div class="sub">Created with curiosity by Raiyan Bin Rais</div>
    </div>
    <div class="spacer"></div>

    <!-- Theme toggle: sliding switch with sun/moon icons -->
    <button id="themeToggleBtn" class="theme-switch" aria-label="Toggle theme" title="Toggle theme">
      <span class="ts-icon ts-moon" aria-hidden="true">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 1 0 9.79 9.79z"></path>
        </svg>
      </span>
      <span class="ts-icon ts-sun" aria-hidden="true">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6.76 4.84l-1.8-1.79L3.17 4.84l1.79 1.79 1.8-1.79zM1 13h3v-2H1v2zm10 10h2v-3h-2v3zm9.83-3.16l-1.79-1.79-1.8 1.79 1.8 1.79 1.79-1.79zM20 11v2h3v-2h-3zM12 1h-2v3h2V1zm6.24 3.84l1.79-1.79-1.79-1.79-1.8 1.79 1.8 1.79zM12 6a6 6 0 100 12 6 6 0 000-12zM4.84 17.24l-1.79 1.79 1.79 1.79 1.79-1.79-1.79-1.79z"></path>
        </svg>
      </span>
      <span class="ts-knob" aria-hidden="true"></span>
    </button>
  </header>

  <div class="container">
    <!-- Left: courses -->
    <div class="panel courses" id="coursesPanel">
      <div class="body">
        <h2>Courses</h2>

        <!-- Mobile-only helper text -->
        <div class="mobile-hint mobile-only small">
          Course list is really long, I'd suggest searching for specific courses instead of scrolling down manually.
        </div>

        <!-- Top row: search + mobile Filters button -->
        <div class="toolbar">
          <input type="text" id="search" placeholder="Search course code/title/faculty" />
          <button class="btn" id="btnToggleFilters" aria-expanded="false" aria-controls="filtersWrap">Filters</button>
        </div>

        <!-- Filters row (desktop inline; mobile bottom sheet) -->
        <div id="filtersBackdrop" aria-hidden="true"></div>
        <div class="filtersWrap" id="filtersWrap">
          <select id="filterDay" aria-label="Filter by schedule">
            <option value="">All schedules</option>
            <option value="ST">ST (Sun–Tue)</option>
            <option value="MW">MW (Mon–Wed)</option>
            <option value="AR">AR (Sat–Thu)</option>
          </select>
          <select id="filterAvail" aria-label="Filter by availability">
            <option value="">Any availability</option>
            <option value="open">Open seats</option>
            <option value="full">Full</option>
          </select>
          <button class="btn alt mobile-only" id="btnCloseFilters">Done</button>
        </div>

        <div id="courseError" class="footnote" style="display:none; color:#ff4d4f;"></div>

        <!-- Desktop: table -->
        <div class="table-wrap" id="tableWrap">
          <table class="table" id="courseTable" role="table" aria-label="Courses">
            <thead>
              <tr>
                <th>Course</th>
                <th>Sec</th>
                <th>Days/Time</th>
                <th>Faculty</th>
                <th>Title</th>
                <th class="right">Seats</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="courseTbody">
              <tr><td colspan="7" class="small">Loading courses…</td></tr>
            </tbody>
          </table>
        </div>

        <!-- Mobile: cards -->
        <div class="cards" id="courseCards" aria-live="polite"></div>

        <div class="footnote">Course list is updated by me. However, the plans you make are saved locally in your browser (do not clear cache).</div>
      </div>
    </div>

    <!-- Right: plans + schedule -->
    <div class="panel" id="planPanel">
      <div class="body">
        <h2>Plans</h2>
        <div class="row" style="margin-bottom:8px">
          <div class="plans" id="plans"></div>
          <button class="btn plan new" id="btnQuickAddPlan" title="New plan">+ New Plan</button>
        </div>
        <div class="row" style="margin-bottom:8px">
          <input type="text" id="newPlanName" placeholder="New plan name (optional)" />
          <button class="btn accent" id="btnAddPlan">Add Plan</button>
          <button class="btn" id="btnRenamePlan">Rename</button>
          <button class="btn" id="btnDuplicatePlan">Duplicate</button>
          <button class="btn danger" id="btnDeletePlan">Delete</button>
        </div>

        <div style="border-top:1px solid var(--border); margin:10px 0"></div>

        <div class="legend">
          <div class="pill">A: Sat</div>
          <div class="pill">S: Sun</div>
          <div class="pill">M: Mon</div>
          <div class="pill">T: Tue</div>
          <div class="pill">W: Wed</div>
          <div class="pill">R: Thu</div>
        </div>

        <div class="plan-title" id="planTitle">Plan A</div>

        <!-- Mobile day tabs -->
        <div class="day-tabs" id="dayTabs" aria-label="Select day"></div>

        <!-- Desktop schedule grid -->
        <div class="schedule desktop" id="schedule"></div>

        <!-- Mobile schedule list -->
        <div class="m-schedule" id="mSchedule"></div>

        <div style="margin-top:12px;">
          <div class="row" style="justify-content: space-between;">
            <div class="small">Conflicts are prevented on add.</div>
            <button class="btn" id="btnClearActive">Clear active plan</button>
          </div>
          <div class="section-list" id="planList" style="margin-top:8px;"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite"></div>

<script>
  // ---------- Config ----------
  const DAY_KEYS = ['A','S','M','T','W','R']; // No Friday
  const DAY_NAME_MAP = { A:'Sat', S:'Sun', M:'Mon', T:'Tue', W:'Wed', R:'Thu' };
  const DAY_MAP = Object.fromEntries(DAY_KEYS.map((k,i)=>[k,i]));

  // Current storage key + legacy keys for migration
  const STORAGE_PLANS = 'iub-plans-v7';
  const LEGACY_PLAN_KEYS = ['iub-plans-v7','iub-plans-v6','iub-plans-v5','iub-plans-v4'];
  const STORAGE_THEME = 'iub-theme';

  // Time slots
  const SLOTS = [
    { start: 8*60, end: 9*60+30,  label: '08:00-09:30' },
    { start: 9*60+40, end: 11*60+10, label: '09:40-11:10' },
    { start: 11*60+20, end: 12*60+50, label: '11:20-12:50' },
    { start: 13*60, end: 14*60+30, label: '13:00-14:30' },
    { start: 14*60+40, end: 16*60+10, label: '14:40-16:10' },
    { start: 16*60+20, end: 17*60+50, label: '16:20-17:50' },
  ];
  const SLOT_HEIGHT = 100;
  const HEADER_OFFSET = 24;
  const DAY_GROUPS = { ST: ['S','T'], MW: ['M','W'], AR: ['A','R'] };

  // ---------- State ----------
  let sections = [];
  let plans = [];
  let activePlanId = null;
  const sectionByKey = new Map();
  let activeMobileDay = 'S';
  const mql = window.matchMedia('(max-width: 768px)');
  let isMobile = mql.matches;

  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  function minutesFromHHMM(s) {
    const m = (s||'').match(/^\s*(\d{2})(\d{2})\s*$/);
    if (!m) return null;
    return parseInt(m[1],10)*60 + parseInt(m[2],10);
  }
  function parseDaysTime(str) {
    const src = (str || '').trim();
    const m = src.match(/^([A-Z]+)\s*:\s*(\d{3,4})\s*-\s*(\d{3,4})$/i);
    if (!m) return null;
    const rawDays = (m[1] || '').trim().toUpperCase();
    const dayCodes = rawDays.split('').filter(d => DAY_KEYS.includes(d));
    const start = minutesFromHHMM(m[2]);
    const end = minutesFromHHMM(m[3]);
    if (!dayCodes.length || start == null || end == null) return null;
    const label = `${rawDays}: ${m[2].trim()}-${m[3].trim()}`; // normalized
    return { days: dayCodes, start, end, label };
  }
  function keyOf(sec) { return `${sec.course}|${sec.section}|${sec.timing.label}|${(sec.faculty||'').trim()}`; }
  function saveAll() { localStorage.setItem(STORAGE_PLANS, JSON.stringify({ plans, activePlanId })); }

  // Read a plans blob from a specific key
  function readPlansKey(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (parsed && Array.isArray(parsed.plans)) return parsed;
    } catch {}
    return null;
  }

  // Load from the newest available key (migrates legacy keys automatically)
  function loadAll() {
    let found = null;
    let foundKey = null;
    for (const k of LEGACY_PLAN_KEYS) {
      const maybe = readPlansKey(k);
      if (maybe && maybe.plans) { found = maybe; foundKey = k; break; }
    }
    if (found) {
      plans = Array.isArray(found.plans) ? found.plans : [];
      activePlanId = found.activePlanId || plans[0]?.id || null;
      if (foundKey !== STORAGE_PLANS) saveAll();
    }
    if (!Array.isArray(plans) || plans.length === 0) {
      const id = 'p_' + Math.random().toString(36).slice(2);
      plans = [{ id, name: 'Plan A', items: [] }];
      activePlanId = id;
      saveAll();
    }
  }

  // Fallback resolver: map old saved keys to current sections (course/section/faculty/time)
  function resolveSectionFromKey(k) {
    const parts = (k||'').split('|');
    const course = parts[0] || '';
    const sectionNum = parseInt(parts[1] || '0', 10);
    const label = parts[2] || '';
    const faculty = (parts[3] || '').trim();

    let candidates = sections.filter(s => s.course === course && s.section === sectionNum);
    if (faculty) candidates = candidates.filter(s => (s.faculty||'').trim() === faculty);

    if (candidates.length > 1 && label) {
      const m = label.match(/(\d{2}):?(\d{2})-(\d{2}):?(\d{2})/);
      if (m) {
        const start = parseInt(m[1],10)*60 + parseInt(m[2],10);
        const end   = parseInt(m[3],10)*60 + parseInt(m[4],10);
        const byTime = candidates.find(s => s.timing.start === start && s.timing.end === end);
        if (byTime) return byTime;
      }
    }
    return candidates[0] || null;
  }

  // Return resolved items for the active plan (backward compatible)
  function resolvePlanItems(plan) {
    const out = [];
    for (const k of (plan?.items || [])) {
      const exact = sectionByKey.get(k);
      if (exact) { out.push(exact); continue; }
      const fallback = resolveSectionFromKey(k);
      if (fallback) out.push(fallback);
    }
    return out;
  }

  // One-time migration: rewrite old keys to canonical keys so future loads are exact
  function migratePlanKeys() {
    let changed = false;
    for (const p of plans) {
      const items = resolvePlanItems(p);
      const newKeys = Array.from(new Set(items.map(keyOf)));
      if (newKeys.length !== p.items.length || newKeys.some((v,i)=>v!==p.items[i])) {
        p.items = newKeys;
        changed = true;
      }
    }
    if (changed) saveAll();
  }

  function updateThemeColorMeta(theme) {
    let meta = document.querySelector('meta[name="theme-color"]:not([media])');
    const color = theme === 'light' ? '#f3f4f6' : '#0b0f14';
    if (!meta) {
      meta = document.createElement('meta');
      meta.setAttribute('name','theme-color');
      document.head.appendChild(meta);
    }
    meta.setAttribute('content', color);
  }
  function applyThemeOnLoad() {
    const saved = localStorage.getItem(STORAGE_THEME);
    const theme = saved === 'light' ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', theme);
    syncThemeButton(theme);
    updateThemeColorMeta(theme);
  }
  function setTheme(isLight) {
    const theme = isLight ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem(STORAGE_THEME, theme);
    syncThemeButton(theme);
    updateThemeColorMeta(theme);
  }
  function syncThemeButton(theme) {
    const btn = $('#themeToggleBtn');
    if (!btn) return;
    const isLight = theme === 'light';
    btn.setAttribute('aria-label', isLight ? 'Switch to dark theme' : 'Switch to light theme');
  }
  function reindex() { sectionByKey.clear(); for (const sec of sections) sectionByKey.set(keyOf(sec), sec); }
  function overlaps(a, b) { return a.start < b.end && b.start < a.end; }
  function findConflictingWith(items, candidate) {
    for (const s of items) {
      const daySet = new Set(s.timing.days);
      if (!candidate.timing.days.some(d => daySet.has(d))) continue;
      if (overlaps({start:s.timing.start, end:s.timing.end}, {start:candidate.timing.start, end:candidate.timing.end})) return s;
    }
    return null;
  }
  function seatStatus(sec) { const open = Math.max(sec.capacity - sec.enrolled, 0); return { open, full: open === 0 }; }
  function showToast(msg) { const t = $('#toast'); t.textContent = msg; t.classList.add('show'); clearTimeout(showToast._timer); showToast._timer = setTimeout(()=>t.classList.remove('show'), 2800); }
  function slotIndexFor(start, end) { for (let i=0;i<SLOTS.length;i++) if (SLOTS[i].start===start && SLOTS[i].end===end) return i; return -1; }
  function inDayGroup(sec, groupKey) { const group = DAY_GROUPS[groupKey]; if (!group) return true; return sec.timing.days.some(d => group.includes(d)); }
  function hhmm(n){ const h=String(Math.floor(n/60)).padStart(2,'0'); const m=String(n%60).padStart(2,'0'); return `${h}:${m}`; }

  // ---------- Backend load ----------
  async function loadSectionsFromBackend() {
    const tbody = $('#courseTbody'); const errorBox = $('#courseError');
    try {
      const resp = await fetch('data/courses.json', { cache: 'no-store' });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      const data = await resp.json();
      sections = (data || []).map(row => {
        const tParsed = parseDaysTime(row.days_time);
        if (!tParsed) return null;
        return {
          course: row.course || 'UNKNOWN',
          section: parseInt(row.section || '0', 10) || 0,
          title: row.title || '',
          faculty: (row.faculty || '').toString(),
          timing: tParsed,
          enrolled: parseInt(row.enrolled || '0', 10) || 0,
          capacity: parseInt(row.capacity || '0', 10) || 0,
          credits: parseInt(row.credits || '0', 10) || 0,
          cat: row.cat || ''
        };
      }).filter(Boolean);
      reindex();

      // After we know all sections, migrate any legacy keys once
      migratePlanKeys();

      errorBox.style.display = 'none';
    } catch (e) {
      sections = []; reindex();
      errorBox.textContent = 'Failed to load courses. Please try again later.';
      errorBox.style.display = 'block';
      if (tbody) tbody.innerHTML = '<tr><td colspan="7" class="small">No courses available.</td></tr>';
    }
  }

  // ---------- Rendering ----------
  function renderPlans() {
    const cont = $('#plans'); cont.innerHTML = '';
    for (const p of plans) {
      const btn = document.createElement('button');
      btn.className = 'plan' + (p.id === activePlanId ? ' active' : '');
      btn.textContent = p.name;
      btn.onclick = () => { activePlanId = p.id; saveAll(); renderAll(); };
      cont.appendChild(btn);
    }
    const plan = plans.find(p => p.id === activePlanId);
    $('#planTitle').textContent = plan ? plan.name : '—';
  }

  function filteredSections() {
    const q = ($('#search').value || '').toLowerCase();
    const groupFilter = $('#filterDay').value || '';
    const availFilter = $('#filterAvail').value || '';
    return sections.filter(sec => {
      const hay = `${sec.course} ${sec.title} ${sec.faculty}`.toLowerCase();
      if (q && !hay.includes(q)) return false;
      if (groupFilter && !inDayGroup(sec, groupFilter)) return false;
      if (availFilter) {
        const { full } = seatStatus(sec);
        if (availFilter === 'open' && full) return false;
        if (availFilter === 'full' && !full) return false;
      }
      return true;
    });
  }

  function renderCourseTableOrCards() {
    const list = filteredSections();
    const tbody = $('#courseTbody');
    const cards = $('#courseCards');

    if (!isMobile) {
      // Desktop: table
      $('#tableWrap').style.display = '';
      cards.style.display = 'none';
      tbody.innerHTML = '';
      const active = plans.find(p => p.id === activePlanId);

      for (const sec of list) {
        const tr = document.createElement('tr');
        const { open, full } = seatStatus(sec);

        tr.innerHTML = `
          <td class="nowrap"><strong>${sec.course}</strong></td>
          <td>${sec.section}</td>
          <td><span class="tag">${sec.timing.label}</span></td>
          <td class="wrap"></td>
          <td class="wrap">${sec.title || ''}</td>
          <td class="right"><span class="avail ${full ? 'full' : 'ok'}">${open}/${sec.capacity}</span></td>
          <td class="actions"></td>
        `;
        tr.children[3].textContent = sec.faculty || '';

        const actions = tr.querySelector('.actions');
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn';
        btnAdd.textContent = 'Add to plan';
        btnAdd.onclick = () => tryAddToPlan(sec, active);
        actions.appendChild(btnAdd);

        tbody.appendChild(tr);
      }
    } else {
      // Mobile: cards
      $('#tableWrap').style.display = 'none';
      cards.style.display = 'grid';
      cards.innerHTML = '';
      const active = plans.find(p => p.id === activePlanId);

      for (const sec of list) {
        const { open, full } = seatStatus(sec);
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="card-top">
            <div class="card-title">${sec.course} • Sec ${sec.section}</div>
            <div class="tag">${sec.timing.label}</div>
          </div>
          <div class="card-sub">${sec.title || ''}</div>
          <div class="card-meta">
            <span class="small"><strong>Faculty:</strong> <span class="fac"></span></span>
            <span class="small"><strong>Seats:</strong> <span class="${full ? 'avail full' : 'avail ok'}">${open}/${sec.capacity}</span></span>
          </div>
          <div class="card-actions">
            <button class="btn">Add to plan</button>
          </div>
        `;
        card.querySelector('.fac').textContent = sec.faculty || '';
        card.querySelector('.btn').onclick = () => tryAddToPlan(sec, active);
        cards.appendChild(card);
      }
    }
  }

  function tryAddToPlan(sec, active) {
    if (!active) return showToast('Create and select a plan first.');
    const existingItems = resolvePlanItems(active); // use resolved items
    if (existingItems.some(x => x.course === sec.course)) {
      showToast(`You can't choose two sections of the same course (${sec.course}). Remove the other section first.`);
      return;
    }
    const conflict = findConflictingWith(existingItems, sec);
    if (conflict) {
      showToast(`Cannot add: ${sec.course} Sec-${sec.section} (${sec.timing.label}) conflicts with ${conflict.course} Sec-${conflict.section} (${conflict.timing.label}).`);
      return;
    }
    const k = keyOf(sec);
    if (!active.items.includes(k)) active.items.push(k);
    saveAll(); renderAll();
    showToast(`Added ${sec.course} Sec-${sec.section} ${hhmm(sec.timing.start)}-${hhmm(sec.timing.end)}`);
  }

  function renderSchedule() {
    const sched = $('#schedule');
    const mSched = $('#mSchedule');
    const plan = plans.find(p => p.id === activePlanId);
    const items = resolvePlanItems(plan);

    if (!isMobile) {
      $('#dayTabs').style.display = 'none';
      mSched.style.display = 'none';
      sched.style.display = 'block';
      sched.innerHTML = '';

      sched.style.height = (HEADER_OFFSET + SLOTS.length * SLOT_HEIGHT) + 'px';

      // Left slot rail with header spacer
      const slots = document.createElement('div');
      slots.className = 'slots';
      const slotsHeader = document.createElement('div');
      slotsHeader.className = 'slots-header';
      slots.appendChild(slotsHeader);
      for (let i=0;i<SLOTS.length;i++) {
        const row = document.createElement('div');
        row.className = 'slot';
        row.style.top = `${HEADER_OFFSET + i*SLOT_HEIGHT}px`;
        row.style.height = `${SLOT_HEIGHT}px`;
        row.textContent = SLOTS[i].label;
        slots.appendChild(row);
      }
      sched.appendChild(slots);

      // Day columns (A,S,M,T,W,R)
      const days = document.createElement('div');
      days.className = 'days';
      for (let d = 0; d < DAY_KEYS.length; d++) {
        const col = document.createElement('div');
        col.className = 'day-col';
        const header = document.createElement('div');
        header.className = 'day-header';
        const dk = DAY_KEYS[d];
        header.innerHTML = `<strong>${DAY_NAME_MAP[dk]}</strong>`;
        col.appendChild(header);
        for (let i=0;i<SLOTS.length;i++) {
          const line = document.createElement('div');
          line.style.position = 'absolute';
          line.style.left = '0'; line.style.right = '0';
          line.style.top = `${HEADER_OFFSET + i*SLOT_HEIGHT}px`;
          line.style.borderTop = '1px dashed var(--grid-line)';
          col.appendChild(line);
        }
        days.appendChild(col);
      }
      sched.appendChild(days);

      // Blocks
      for (const sec of items) {
        const idx = slotIndexFor(sec.timing.start, sec.timing.end);
        const top = (idx >= 0 ? HEADER_OFFSET + idx * SLOT_HEIGHT + 6 : HEADER_OFFSET + 6);
        const height = (idx >= 0 ? SLOT_HEIGHT - 12 : SLOT_HEIGHT - 12);
        for (const d of sec.timing.days) {
          const dayIdx = DAY_MAP[d];
          const block = document.createElement('div');
          block.className = 'block';
          block.style.top = `${top}px`;
          block.style.height = `${height}px`;
          block.innerHTML = `
            <div><strong>${sec.course}</strong> Sec ${sec.section}</div>
            <div class="small">${sec.timing.label} • ${sec.title || ''}</div>
            <div class="small"></div>
          `;
          block.querySelector('.small:last-child').textContent = sec.faculty || '';
          const dayCol = sched.querySelector('.days').children[dayIdx];
          block.style.left = '6px';
          block.style.right = '6px';
          dayCol.appendChild(block);
        }
      }
    } else {
      // Mobile per-day view
      $('#dayTabs').style.display = 'flex';
      sched.style.display = 'none';
      mSched.style.display = 'block';
      mSched.innerHTML = '';

      if (!DAY_KEYS.includes(activeMobileDay)) activeMobileDay = DAY_KEYS[0];

      // Day tabs
      const tabs = $('#dayTabs');
      tabs.innerHTML = '';
      for (const dk of DAY_KEYS) {
        const tab = document.createElement('button');
        tab.className = 'day-tab' + (dk === activeMobileDay ? ' active' : '');
        tab.textContent = DAY_NAME_MAP[dk];
        tab.onclick = () => { activeMobileDay = dk; renderSchedule(); };
        tabs.appendChild(tab);
      }

      // Build per-slot list for the selected day
      for (let i=0; i<SLOTS.length; i++) {
        const slot = SLOTS[i];
        const row = document.createElement('div');
        row.className = 'm-slot';
        const label = document.createElement('div');
        label.className = 'm-slot-label';
        label.textContent = slot.label;
        row.appendChild(label);

        const inThisSlot = items.filter(s =>
          s.timing.days.includes(activeMobileDay) &&
          s.timing.start === slot.start &&
          s.timing.end === slot.end
        );

        if (inThisSlot.length === 0) {
          const none = document.createElement('div');
          none.className = 'small';
          none.textContent = '—';
          row.appendChild(none);
        } else {
          for (const sec of inThisSlot) {
            const card = document.createElement('div');
            card.className = 'm-block';
            card.innerHTML = `
              <div><strong>${sec.course}</strong> Sec ${sec.section}</div>
              <div class="small">${sec.title || ''}</div>
              <div class="small"></div>
            `;
            card.querySelector('.small:last-child').textContent = sec.faculty || '';
            row.appendChild(card);
          }
        }

        mSched.appendChild(row);
      }
    }
  }

  function renderPlanList() {
    const plan = plans.find(p => p.id === activePlanId);
    const items = resolvePlanItems(plan);
    const list = $('#planList');
    list.innerHTML = '';
    for (const sec of items) {
      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `
        <div class="wrap">
          <strong>${sec.course}</strong> Sec ${sec.section}
          <span class="tag">${hhmm(sec.timing.start)}-${hhmm(sec.timing.end)}</span>
          <div class="small">${sec.title}</div>
          <div class="small"></div>
        </div>
      `;
      div.querySelector('.small:last-child').textContent = sec.faculty || '';
      const r = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'btn danger';
      btn.textContent = 'Remove';
      btn.onclick = () => {
        // Remove by either exact key or by course+section (legacy entries)
        const exactKey = keyOf(sec);
        plan.items = plan.items.filter(x => {
          if (x === exactKey) return false;
          const [c,s] = (x||'').split('|');
          return !(c === sec.course && parseInt(s||'0',10) === sec.section);
        });
        saveAll(); renderAll();
      };
      r.appendChild(btn);
      div.appendChild(r);
      list.appendChild(div);
    }
  }

  function renderAll() {
    renderPlans();
    renderCourseTableOrCards();
    renderSchedule();
    renderPlanList();
  }

  // ---------- Header compact behavior (mobile) ----------
  const headerEl = $('#appHeader');
  function updateHeaderCompact() {
    if (!headerEl) return;
    const shouldCompact = isMobile && window.scrollY > 20;
    headerEl.classList.toggle('compact', shouldCompact);
  }
  window.addEventListener('scroll', updateHeaderCompact, { passive: true });

  // Filters (mobile) bottom sheet toggles
  $('#btnToggleFilters').onclick = () => {
    const wrap = $('#filtersWrap');
    const bd = $('#filtersBackdrop');
    const open = !wrap.classList.contains('open');
    wrap.classList.toggle('open', open);
    bd.classList.toggle('show', open);
    $('#btnToggleFilters').setAttribute('aria-expanded', open ? 'true' : 'false');
  };
  $('#filtersBackdrop').onclick = () => {
    $('#filtersWrap').classList.remove('open');
    $('#filtersBackdrop').classList.remove('show');
    $('#btnToggleFilters').setAttribute('aria-expanded', 'false');
  };
  $('#btnCloseFilters').onclick = () => {
    $('#filtersWrap').classList.remove('open');
    $('#filtersBackdrop').classList.remove('show');
    $('#btnToggleFilters').setAttribute('aria-expanded', 'false');
  };

  // Theme toggle (switch)
  $('#themeToggleBtn').addEventListener('click', () => {
    const current = document.documentElement.getAttribute('data-theme') || 'dark';
    setTheme(current !== 'light');
  });

  // Mobile breakpoint watcher
  const mqlHandler = (e) => { isMobile = e.matches; updateHeaderCompact(); renderAll(); };
  if (mql.addEventListener) mql.addEventListener('change', mqlHandler); else mql.addListener(mqlHandler);

  // ---------- PWA: Service Worker ----------
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('service-worker.js')
        .then(reg => { reg.update?.(); })
        .catch(err => console.warn('SW registration failed', err));
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (refreshing) return; refreshing = true; window.location.reload();
      });
    });
  }

  // ---------- Init ----------
  applyThemeOnLoad();
  loadAll();
  loadSectionsFromBackend().then(() => { renderAll(); updateHeaderCompact(); });
</script>
</body>
</html>
